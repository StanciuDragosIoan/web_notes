<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css2?family=Domine:wght@400;700&family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Roboto&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="../../../assets/css/main.css"
      type="text/css"
    />
    <title>Git basic</title>
  </head>
  <body>
    <h1 class="header">Git basic</h1>
    <p class="text">
      Git is a distributed version-control system for tracking changes in source
      code during software development. It is designed for coordinating work
      among programmers, but it can be used to track changes in any set of
      files.
    </p>
    <p class="center text bold">How squash multiple commits</p>
    <p class="text">
      If we have multiple commits on a branch, it is a good idea to squash them
      all before merging the branch into another branch or even pushing it onto
      the remote repository.
    </p>
    <p class="text">
      Let's say we are on our development branch and we have 3 commits, we can
      confirm that by running:
    </p>
    <pre class="code">
      git log
    </pre>
    <p class="text">
      The output to that command will be:
    </p>
    <div class="devPic">
      <img src="./img/git_squash.png" alt="" />
    </div>
    <p class="text">
      So on the <span class="snippet">squash_branch</span> we have 3 commits.
      Let's say we want to keep only 1 and squash the changes from the other 2
      into it.
    </p>
    <p class="text">
      In order to do that we have to run the below command:
    </p>
    <pre class="code">
      git rebase -i --root
    </pre>
    <p class="text">
      We can replace <span class="snippet">--root</span> with the hash of the
      commit we want to squash into (so the one up until which we will squash).
      By default <span class="snippet">--root</span> will take our latest
      commit.The command above will enter in
      <span class="snippet">nano</span> mode (similar to vim):
    </p>
    <div class="devPic">
      <img src="./img/vim.png" alt="" />
    </div>
    <p class="text">
      At the top of the window we have the 3 commits in our history:
    </p>
    <p class="text">
      <span class="snippet">pick 5e7ce76 created file</span>
      <br />
      <span class="snippet">pick 301999c started writing to file</span>
      <br />
      <span class="snippet">pick fb2d352 3rd commit</span>
    </p>
    <p class="text">
      By default you are in <span class="snippet">nano</span> edit mode. Now in
      the terminal window replace the last 2
      <span class="snippet">pick</span> commands with
      <span class="snippet">s</span> from squash and leave the first
      <span class="snippet">pick</span> command there.
    </p>
    <p class="text">Your window will look like this:</p>
    <div class="devPic">
      <img src="./img/squash.png" alt="" />
    </div>
    <p class="text">
      Then press <span class="snippet">ctr + x</span> and you will be prompted
      to confirm as below:
    </p>
    <div class="devPic">
      <img src="./img/confirm_1st.png" alt="" />
    </div>
    <p class="text">
      Confirm by typing
      <span class="snippet">y</span> and then press
      <span class="snippet">enter</span> .
    </p>
    <p class="text">
      Next the window will prompt you to edit the commit message:
    </p>
    <div class="devPic">
      <img src="./img/edit.png" alt="" />
    </div>
    <p class="text">Edit the message:</p>
    <div class="devPic">
      <img src="./img/edited.png" alt="" />
    </div>
    <p class="text">Press <span class="snippet">ctrl + x</span>:</p>
    <div class="devPic">
      <img src="./img/saved.png" alt="" />
    </div>
    <p class="text">
      Next type in <span class="snippet">y</span> and hit
      <span class="snippet">enter</span> to confirm
    </p>
    <p class="text">
      Next in the terminal if you type <span class="snippet">git log</span> you
      will see only 1 commit hash instead of 3 with the latest message (the one
      you edited):
    </p>
    <div class="devPic">
      <img src="./img/final_log.png" alt="" />
    </div>
    <h1 class="header">Basic git workflow</h1>
    <p class="text">
      In order to clone a repository locally with all its branches we can simply
      clone it with:
    </p>
    <pre class="code">
      git clone &lt;link to repo&gt;
    </pre>
    <p class="text">
      Say we have the following repo:
    </p>
    <div class="devPic">
      <img src="./img/playground.png" alt="" />
    </div>
    <p class="text">
      As we can see, we have 3 branches in our remote repo:
    </p>
    <div class="devPic">
      <img src="./img/branches.png" alt="" />
    </div>
    <p class="text">
      If we want the repo locally, we can simply clone it by running:
    </p>
    <pre class="code" style="font-size:0.7rem;">
  git clone https://github.com/StanciuDragosIoan/git_playground.git
    </pre>
    <p class="text">
      Next if we <span class="snippet">cd</span> into the project and we check
      the branches by running <span class="snippet">git branch</span>, we can
      see that we are on the <span class="snippet">master</span> branch and we
      do not have the other two:
    </p>
    <div class="devPic">
      <img src="./img/master.png" alt="" />
    </div>
    <p class="text">
      Also, we can see in both the terminal (by running
      <span class="snippet">git log</span> ) or in the web interface, on the
      master branch we only have 1 commit:
    </p>
    <div class="devPic">
      <img src="./img/master_commit.png" alt="" />
    </div>
    <p class="text">
      If we want to grab only the <span class="snippet">Feature-2</span> branch,
      we can do so by running <span class="snippet">git checkout &lt;branch name &gt;</branch></span>
    </p>
    <pre class="code">
      git checkout Feature-2
    </pre>
    <p class="text">
      In the terminal we will see that we have now the <span class="snippet">Feature-2</span> branch.
    </p>
    <div class="devPic">
      <img src="./img/feature_2.png" alt="">
    </div>
    <p class="text">
      We are also checked out on it so if we run <span class="snippet">git branch</span>:
    </p>
    <div class="devPic">
      <img src="./img/feature_2_checked.png" alt="">
    </div>
    <p class="text">
      Also if we run <span class="snippet">git log</span> we can see that on <span class="snippet">Feature-2</span>  branch we have 3 commits instead of 1:
    </p>
    <div class="devPic">
      <img src="./img/feature_2_commits.png" alt="">
    </div>
    <p class="text">
      If we want to delete a branch we need to be on a different one and then we can proceed with the delete.
      Delete Feature-2 branch locally by running:
    </p>
    <pre class="code">
      git checkout master
      git branch -D Feature-2
    </pre>
    <p class="text">
      Now the Feature-2 branch is deleted:
    </p>
    <div class="devPic">
      <img src="./img/delete.png" alt="">
    </div>
    <p class="text">
      If we run <span class="snippet">git branch</span> again, we can see that we are
      on master and we have none of the other branches:
    </p>
    <div class="devPic">
      <img src="./img/back_master.png" alt="">
    </div>
    <h1 class="header">Rebase basics</h1>
    <p class="text">
      Let's say we work on a feature branch, which was started from the development branch,
      the development branch was updated since we started developing our feature, and we need the
      updates in our feature branch.
    </p>
    <p class="text">
      The workflow for that will be something like:
    </p>
    <p class="text">
      On a workflow having <span class="snippet">master</span>  and <span class="snippet">development</span> branches, we start developing a <span class="snippet">feature-1</span> branch
      and a <span class="snippet">feature-2</span> branch one after the other (they are created from the <span class="snippet">development</span> branch). However, the <span class="snippet">feature-1</span>
      is finished first and merged into the <span class="snippet">development</span> branch and our <span class="snippet">feature-2</span>
      branch needs that new code (which is now merged into the <span class="snippet">development</span> branch).
    </p>
    <p class="text">
      The trick we need to use for this is called <span class="snippet">git rebase</span> and it is basically the process of
      moving around or combining some commits to a new base commit (so we rewrite) the history of the current branch. 
    </p>
    <p class="text">
      As for our demo, go create an <span class="snippet">index.html</span> file, into which we will work.
      First, initialize git, and create a <span class="snippet">master</span> branch. Then do a commit on it:
    </p>
    <div class="devPic">
      <img src="./img/master_branch.png" alt="">
    </div>
    <p class="text">
      Next, let's create a <span class="snippet">development</span> branch and do a commit on it:
    </p>
    <div class="devPic">
      <img src="./img/development_branch.png" alt="">
    </div>
    <p class="text">
      Now we have an initial <span class="snippet">master</span> branch, with a single commit on it, and a <span class="snippet">development</span>
      branch with 2 commits on it. We can see that by running <span class="snippet">git log</span> on each branch.
    </p>
    <p class="text center">So on <span class="snippet">master</span> we have:</p>
    <div class="devPic">
      <img src="./img/git_log_master.png" alt="">
    </div>
    <p class="text center">
      And on <span class="snippet">development</span> we have:
    </p>
    <div class="devPic">
      <img src="./img/git_log_development.png" alt="">
    </div>
    <p class="text">
      *note how on the <span class="snippet">development</span> we have an extra commit.
    </p>
    <p class="text">
      Now let's create a <span class="snippet">feature-1</span> branch from the <span class="snippet">development</span> branch and develop a feature.
      Our feature will require 2 commits:
    </p>
    <div class="devPic">
      <img src="./img/git_log_feature_1.png" alt="">
    </div>
    <p class="text">
      *note how the <span class="snippet">feature-1</span> branch has 2 commits and is created from the development branch.
    </p>
    <p class="text">
      Let's now create a <span class="snippet">feature-2</span> branch from the development. The <span class="snippet">feature-2</span>
      branch will have 3 commits:
    </p>
    <div class="devPic">
      <img src="./img/git_log_feature_2.png" alt="">
    </div>
    <p class="text">
      *note how the <span class="snippet">feature-2</span> branch has 3 commits and is created from the development branch.
    </p>
    <p class="text">
      Now let's merge <span class="snippet">feature-1</span> into the development <span class="snippet">development</span> branch.
      Now the development branch will look like this:
    </p>
    <div class="devPic">
      <img src="./img/git_log_new_development.png" alt="">
    </div>
    <p class="text">*note how the <span class="snippet">development</span> branch has now 3 commits in it (the initial one plus the 2 we have
    merged from the <span class="snippet">feature-1</span> branch.</p>
    <p class="text">
      Now let's suppose we need the code from <span class="snippet">feature-1</span> into <span class="snippet">feature-2</span>. We will need to 
      do a rebase for that. Let's start by <span class="snippet">squashing</span> the 3 commits from <span class="snippet">feature-2</span> into a single one.
      After <span class="snippet">squash</span> the <span class="snippet">feature-2</span> branch looks like this:
    </p>
    <div class="devPic">
      <img src="./img/git_squash_2.png" alt="">
    </div>
    <p class="text">
      *note how we have <span class="snippet">squashed</span> the <span class="snippet">feature-2</span> branch down to a single commit (and since I used the 
      <span class="snippet">git rebase -i --root</span> command and left the first commit there, that commit it's the one creating the <span class="snippet">master</span> 
      branch).
    </p>
    <p class="text">
      Now we can do the <span class="snippet">rebase</span> with the <span class="snippet">development</span> branch. While being on the <span class="snippet">feature-2</span>
      branch (and with the <span class="snippet">master</span> branch up to date) run:
    </p>
    <pre class="code">
      git rebase development
    </pre>
    <p class="text">Because we have <span class="snippet">squashed</span> the commits from <span class="snippet">feature-2</span> thus re-writing the 
    history of the branch, we will get a conflict:</p>
    <div class="devPic">
      <img src="./img/git_rebase_conflict.png" alt="">
    </div>
    <p class="text">
      Accept both changes in this case (as we want both <span class="snippet">feature-1</span> and <span class="snippet">feature-2</span> code). Next 
      run <span class="snippet">git add .</span> and <span class="snippet">git rebase --continue</span>. 
      <p class="text">
        Run also <span class="snippet">git commit --amend -m "feature 2 completed"</span> to edit the message of the single commit from <span class="snippet">feature-2</span>.
      </p>
      <p class="text">
        Once the <span class="snippet">conflict</span> has been solved and the 
      <span class="snippet">rebase</span> performed, <span class="snippet">feature-2</span> looks like this:   </p>
    <div class="devPic">
      <img src="./img/git_rebase_finished.png" alt="">
    </div>
    
    <p class="text">
      *note how we have a single commit on the <span class="snippet">feature-2</span> branch but behind it, we have the 2 commits from <span class="snippet">feature-1</span> too
    so we have re-wrote the history of the <span class="snippet">feature-2</span> branch, incorporating the code from <span class="snippet">feature-1</span> without merging it into
    <span class="snippet">feature-2</span> and keeping a clean history.
    </p>
    <h1 class="header">How git stores stuff</h1>
    <p class="text">
      There are 4 <span class="snippets">leves</span> at which git stores stuff:
    </p>
    <p class="text">
      1. Serve level (the code that is in the remote  repo in github or other platforms)
    </p>
    <p class="text">
      2. The local cache (here git stores metadata about the repo such as the hash of the head, etc...)
    </p>
    <p class="text">
      3. The local branch (here's your own code with the local commits and all)
    </p>
    <p class="text">
      4. The <span class="snippet">uncommited</span> changes with <span class="snippet">staged</span> and 
      <span class="snippet">unstaged</span> stuff that we have yet to <span class="snippet">commit</span>
    </p>
    <h1 class="header">git <span class="snippet">pull</span> vs git <span class="snippet">fetch</span></h1>
    <p class="text">
      The basic difference between <span class="snippet">git pull</span> and <span class="snippet">git fetch</span> is that 
      the latter just refreshes the local cache (so it brings changes from the remote repo in github - Layer 1 to the local cache - Layer 2).
      It does this without applying the changes.
    </p>
    <p class="text">In order to test that, just clone this repo: <a href="https://github.com/StanciuDragosIoan/git_playground" target="_blank">github repo</a> </p>
    <p class="text">Once cloned, if we run inside:</p>
    <pre class="code">
      git branch
    </pre>
    <p class="text">
      The output for that is:
    </p>
    <div class="devPic">
      <img src="./img/git_branch_1.png" alt="" />
    </div>
    <p class="text">
      This means that we have cloned the repo, which has copied the master branch to our local machine. It also means that
      the <span class="snippet">local cache</span> level of git (Level 2) has all the branches. So we have them in the local
      cache but not on the local machine. If we run:
    </p>
    <pre class="code">
      git branch -a
    </pre>
    <p class="text">
      We get the below:
    </p>
    <div class="devPic">
      <img src="./img/git_branch_a_1.png" alt="" />
    </div>
    <p class="text">
      Note that we have all the branches in the cache level (so git 'knows') about all of them but we have a local copy only for the master branch.4
      If we want one of the other branches we just run <span class="snippet">git checkout branch_name</span> for instance:
    </p>
    <pre class="code">
      git checkout Feature-1
    </pre>
    <p class="text">
      Now if we run:
    </p>
    <pre class="code">
      git branch
    </pre>
    <p class="text">We get the below:</p>
    <div class="devPic">
      <img src="./img/git_branch_2.png" alt="" />
    </div>
    <p class="text">
      So now we have a local copy of <span class="snippet">Feature-1</span> too and we are <span class="snippet">checked out</span> on it.
    </p>
    <p class="text">
      Now if we create a new branch inside the remote repo (so from the web interface) and we run again <span class="snippet">git branch -a</span>,
      it will not show the newly created branch. However, if we run:
    </p>
    <pre class="code">
      git fetch
    </pre>
    <div class="devPic">
      <img src="./img/git_fetch_1.png" alt="" />
    </div>
    <p class="text">
      *note how it has all the branches now, after the <span class="snippet">fetch</span> because git fetch has updated our cached level with 
      the latest info from git (with Feature-3).
    </p>
    <p class="text">
      Another example, would be to do a commit onto one of the remote branches from the web interface (as if some1 else had pushed onto it). 
    </p>
    <p class="text">
      In order to perform this test, just run:
    </p>
    <pre class="code">
      git checkout Feature-3
    </pre>
    <p class="text">
      Next, make a commit in the <span class="snippet">Feature-3</span> branch (from the web interface of github) and run:
    </p>
    <pre class="code">
      git diff Feature-3 origin/Feature-3
    </pre>
    <p class="text">
      This command will give no output at all because our local git is not aware of the changes in the remote repo.
    </p>
    <p class="text">
      However if we run <span class="snippet">git fetch</span> and then <span class="snippet">git diff Feature-3 origin/Feature-3</span>
      we get the below output:
    </p>
    <div class="devPic">
      <img src="./img/git_fetch_2.png" alt="" />
    </div>
    <p class="text">
      Note that there is 1 commit difference in <span class="snippet">Feature-3</span> between local and the origin. So now if we run <span class="snippet">git pull</span>
      we will get that local commit too. Also, keep in mind that <span class="snippet">git pull</span> performs a <span class="snippet">fetch</span>
      and a <span class="snippet">merge</span> under the hood so another difference between the <span class="snippet">pull</span> and <span class="snippet">git merge FETCH_HEAD</span>
      command would be the fact that the former applies the changes, while the <span class="snippet">fetch</span> only writes them in the local cache (Level 2). This is useful for when
      we want to see the changes but we may not want to apply them to our local branch.
    </p>
    <p class="text">
      In a nutshell we want to use <span class="snippet">git fetch</span> when we want to see the remote changes on a branch without applying them (but this is cumbersome because we 
      need to run <span class="snippet">git fetch</span>  followed by <span class="snippet">git diff fetched_branch origin/fetched_branch</span> ). It would
      probably be easier to check the chances in the web interface directly. However you must use <span class="snippet">git fetch</span> when a new branch is pushed onto the remote repo
      after you have cloned it locally
      and you need it too (git only cloned the branches that were in the remote repo at the moment of your cloning so if someone else pushes an extra branch and you need it locally, you need
      to do a <span class="snippet">git fetch</span>).
    </p>

    <p class="center text bold">How squash the last N commits</p>
    <pre class="code">
      git reset --soft HEAD~3 //N here
      git commit -m 'msg'
    </pre>
  </body>
</html>
