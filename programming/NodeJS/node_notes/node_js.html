<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <link
      href="https://fonts.googleapis.com/css2?family=Domine:wght@400;700&family=Open+Sans:ital,wght@0,400;0,600;0,700;1,400;1,600;1,700&family=Roboto&display=swap"
      rel="stylesheet"
    />
    <link
      rel="stylesheet"
      href="../../../assets/css/main.css"
      type="text/css"
    />
    <title>Node_JS</title>
  </head>
  <body>
    <h1 class="header">NodeJS (basic)</h1>
    <p class="text center bold">Create a Server in NodeJS</p>
    <p class="text">
      NodeJS has a bunch of core modules (http, https, fs, path, os). We can
      also install 3rd party modules.
    </p>
    <p class="text">
      For creating a server we use the http module (which allows us to launch a
      server, or send a request). Https is used for launching an SSL encoded
      server.
    </p>
    <p class="text">
      For creating a server, we need to import the http module:
    </p>
    <pre class="code">
      //import http module
      const http = require("http");
    </pre>
    <p class="text">
      In order to create the server we use the
      <span class="snippet">createServer()</span> method. It takes a request
      listener as an argument. A request listener is a callback function that
      will execute for every request. The request listener takes in a request
      and a response object, so we can read data from the request or send back a
      response to the request.
    </p>
    <pre class="code">
      //request listener
        function rqListener(req, res) {
           console.log(req); 
           console.log(res);
          }

      //create server 
      const server = http.createServer(rqListener);
    </pre>

    <p class="text">
      We can also pass the request listener as an anonymous function:
    </p>
    <pre class="code">
      const server = http.createServer(
        (req, res) => {
          console.log(req); 
          console.log(res);
        }
      );
    </pre>
    <p class="text">
      Start the server with the <span class="snippet">listen()</span> method
      (which takes in a port and a host as an argument). Since we are on our
      local machine, we do not need to specify a host, it will use localhost by
      default.
    </p>
    <pre class="code">
      //start the server
      server.listen(3000);
    </pre>
    <p class="text">Run the file with:</p>
    <pre class="code">
     node server
   </pre
    >
    <p class="text">
      Go to http://localhost:3000 and you will see nothing (because the server
      is not configured to send back any response), but if you go back in the
      terminal where you ran the file, you will see the request and response
      objects logged, so the server is running.
    </p>
    <p class="text center bold">NodeJS Program Lifecycle</p>
    <p class="text">
      When starting the script, node read it, executed it and it never stopped.
      This happened because of the event loop which is a loop process that keeps
      running as long as there are event listeners listed. One event we
      registered was the request listener callback function. And we never
      unregistered it because the server should be up and running. NodeJS uses
      this event driven approach because it is single threaded but it must also
      handle many connections at once (which it does).
    </p>
    <p class="text">
      In order to unregister an event listener, we need to use the
      <span class="snippet">process.exit()</span> function:
    </p>
    <pre class="code">
      //import http module
      const http = require("http");

      //create server
      const server = http.createServer((req, res) => {
        console.log(req);
        process.exit;//exit on request
      });

      //start the server
      server.listen(3000);
    </pre>
    <p class="text">
      If we run the server.js script now, it will start and it will not stop
      until we make a request to it. Once we make the request, it will log the
      output and stop.
    </p>
    <p class="center text bold">The NodeJS Request</p>
    <p class="text">
      The request object is the object that NodeJS created when we hit the
      <span class="snippet">http://localhost:3000</span> endpoint with our GET
      request.The object has many properties like the headers:
    </p>
    <div class="devPic">
      <img src="./img/headers.png" alt="" />
    </div>
    <p class="text">
      In the request we can see the host, the caching of the response (we have
      no response configured so far), the browser, the http version used, etc..
    </p>
    <p class="text">
      We can even check specific data from the request object via its
      properties:
    </p>
    <pre class="code">
      //import http module
      const http = require("http");

      //create server
      const server = http.createServer(
        (req, res) => {
        //grab specific data
        console.log(req.url, req.method, req.headers);
        process.exit;
      });

      //start the server
      server.listen(3000);
    </pre>
    <p class="text">The output for the above is:</p>
    <div class="devPic">
      <img src="./img/properties.png" alt="" />
    </div>
    <p class="text">
      Note the url is <span class="snippet">/</span>, because we have nothing
      after <span class="snippet">http://localhost:3000</span>. If instead of
      that we type: <span class="snippet">http://localhost:3000/test123</span>,
      we get output as url <span class="snippet">/test123</span>. After the URL
      we have the request (<span class="snippet">GET</span>), followed by the
      headers:
    </p>
    <div class="devPic">
      <img src="./img/properties2.png" alt="" />
    </div>
    <p class="text center bold">Sending back a response</p>
    <p class="text">
      A basic way to send a node response from the server is using the following
      methods: of the response object:
      <span class="snippet">res.setHeader()</span>,
      <span class="snippet">res.write()</span> and
      <span class="snippet">res.end().</span>
    </p>
    <pre class="code">
//import http module
const http = require("http");

//create server
const server = http.createServer(
  (req, res) => {
    //set content type header
    res.setHeader("Content-Type", "text/html");
    //send actual html as response
    res.write("&lt;html&gt;");
    res.write("&lt;head&gt;&lt;title&gt;Basic Page&lt;/title&gt;&lt;/head&gt;");
    res.write("&lt;body&gt;&lt;h1&gt;Hello Node JS&lt;/h1&gt;&lt;/body&gt;");
    res.write("&lt;/html&gt;");
    //end response and send it to client
    res.end(); //can't call write() anymore after end()
});

//start the server
server.listen(3000);

    </pre>
    <p class="text">
      If we open the browser and we go to developer tools, the network tab and
      reload, we can click on the localhost request and if we select the
      <span class="snippet">localhost</span> request, we can see that we have
      the <span class="snippet">Headers</span> tab open by default. We can see
      our <span class="snippet">Content-Type:text/html</span> header set
      together with other default headers set by the browser:
    </p>
    <div class="devPic">
      <img src="./img/chrome_tools.png" alt="" />
    </div>
    <p class="text">
      If we click on the <span class="snippet">Response</span> tab, we can see
      the html response raw (remember, we set it with
      <span class="snippet">res.end():</span>
    </p>
    <div class="devPic">
      <img src="./img/chrome_tools2.png" alt="" />
    </div>
    <p class="text center bold">How to route a reuqest</p>
    <p class="text">In order to route a request, we need to parse the url:</p>
    <pre class="code">
//import http module
const http = require("http");

//create server
const server = http.createServer((req, res) => {
  //parse url
  const url = req.url;
  if (url === "/") {
    //redirect
    res.write("&lt;html&gt;");
    res.write(`&lt;head&gt;
                &lt;title&gt;Enter Msg&lt;/title&gt;
              &lt;/head&gt;`);
    res.write(
      `&lt;body&gt;
        &lt;form action='/message' method='POST'&gt;
          &lt;input type='text' name='message'&gt;
          &lt;button type='submit'&gt;Send&lt;/button&gt;
        &lt;/form&gt;
      &lt;/body&gt;`,
    );
    res.write("&lt;/html&gt;");
    //return so we break execution
    return res.end();
  }
  //set content type header
  res.setHeader("Content-Type", "text/html");
  //send actual html as response
  res.write("&lt;html&gt;");
  res.write(`&lt;head&gt;
              &lt;title&gt;Basic Node Page&lt;/title&gt;
            &lt;/head&gt;`);
  res.write(`&lt;body&gt;
              &lt;h1&gt;Hello from Node JS&lt;/h1&gt;
             &lt;/body&gt;
            `);
  res.write("&lt;/html&gt;");
  //end response and send it to client
});

//start the server
server.listen(3000);

    </pre>
    <p class="text">
      The routing of the request is done when the request hits the
      <span class="snippet">/</span> url. Also, note how we return after the
      <span class="snippet">if (url === "/")</span> statement, in order to
      prevent further execution of the function.
    </p>
    <p class="text">
      If we now go to <span class="snippet">http://localhost:3000</span> we can
      see:
    </p>
    <div class="devPic">
      <img src="./img/basic_form.png" alt="" />
    </div>
    <p class="text">
      Note that on the form we have an
      <span class="snippet">action</span> attribute which indicates the URL
      we'll be redirected to once we submit (<span class="snippet"
        >/message</span
      >). We also have a <span class="snippet">method='POST'</span> attribute
      which indicates the method. The text input field has also a
      <span class="snippet">name</span> attribute. If we submit the form, we
      will get redirected to <span class="snippet">/message</span> route and we
      will see the default view, as the code will skip the
      <span class="snippet">if (url === "/")</span> statement.
    </p>
    <div class="devPic">
      <img src="./img/message_route.png" alt="" />
    </div>

    <p class="text center bold">Redirecting requests</p>
    <p class="text">
      We will redirect the request. When the user submits the form and makes a
      post to <span class="snippet">/message</span>, we will write a file (using
      the <span class="snippet">fs module</span>) and redirect them back to
      <span class="snippet">/</span>.
    </p>
    <pre class="code">
//import http module
const http = require("http");
//import file system module
const fs = require("fs");

//create server
const server = http.createServer((req, res) => {
  //parse url
  const url = req.url;
  if (url === "/") {
    //redirect
    res.write("&lt;html&gt;");
    res.write(`&lt;head&gt;
                &lt;title&gt;Enter Msg&lt;/title&gt;
              &lt;/head&gt;`);
    res.write(
      `&lt;body&gt;
        &lt;form action='/message' method='POST'&gt;
          &lt;input type='text' name='message'&gt;
          &lt;button type='submit'&gt;Send&lt;/button&gt;
        &lt;/form&gt;
      &lt;/body&gt;`,
    );
    res.write("&lt;/html&gt;");
    //return so we break execution
    return res.end();
  }
  //check url and request type
  if (url === "/message" && req.method === "POST") {
    //write new file
    fs.writeFileSync("message.txt", "DUMMY TEXT");
    res.statusCode = 302; //redirect
    res.setHeader("Location", "/");
    //return so we break execution
    return res.end();
  }
  //set content type header
  res.setHeader("Content-Type", "text/html");
  //send actual html as response
  res.write("&lt;html&gt;");
  res.write(`&lt;head&gt;
              &lt;title&gt;Basic Node Page&lt;/title&gt;
            &lt;/head&gt;`);
  res.write(`&lt;body&gt;
              &lt;h1&gt;Hello Node JS&lt;/h1&gt;
             &lt;/body&gt;
            `);
  res.write("&lt;/html&gt;");
  //end response and send it to client
});

//start the server
server.listen(3000);

    </pre>

    <p class="text center bold">
      Parsing request bodies
    </p>
    <p class="text">
      Instead of writing hardcoded text in the message.txt file, we will write
      the data the user sends. In order to do that, we will use the
      <span class="snippet">req.body</span>.
    </p>
    <p class="text center">Streams and buffers</p>
    <p class="text">
      The stream of data is like a process that sends the data continously.Node
      JS reads the request in chunks. At some point, node finishes reading the
      chunks. The good point here is that we can start working on the data in
      chunks without having to parse all of it.
    </p>
    <p class="text">
      In order to actually work with the data, we need to use a buffer. A buffer
      is like some temporary memory into which data is being stored until it
      gets consumed.
    </p>
    <p class="text">
      In order to start parsing the data, we need to register an event listener
      function (that will wait for the POST request to be made). We do that by
      using <span class="snippet">req.on("data", callBack)</span>. The event
      listener listens for the <span class="snippet">"data"</span> event. The
      data event will be fired whenever a new chunk is ready to be read. Once
      the event is fired, the callback function will be executed.
    </p>
    <p class="text">
      Next we will register an
      <span class="snippet">req.on("end", callBack)</span> event listener, which
      will be triggered when the data parsing is finished. The callback function
      will use the <span class="snippet">Buffer</span> to read the data:
    </p>
    <pre class="code">
//import http module
const http = require("http");
//import file system module
const fs = require("fs");

//create server
const server = http.createServer((req, res) => {
  //parse url
  const url = req.url;
  if (url === "/") {
    //redirect
    res.write("&lt;html&gt;");
    res.write(`&lt;head&gt;
                &lt;title&gt;Enter Msg&lt;/title&gt;
              &lt;/head&gt;`);
    res.write(
      `&lt;body&gt;
        &lt;form action='/message' method='POST'&gt;
          &lt;input type='text' name='message'&gt;
          &lt;button type='submit'&gt;Send&lt;/button&gt;
        &lt;/form&gt;
      &lt;/body&gt;`,
    );
    res.write("&lt;/html&gt;");
    //return so we break execution
    return res.end();
  }
  //check url and request type
  if (url === "/message" && req.method === "POST") {
    //register event listener for data
    const body = [];
    req.on("data", (chunk) => {
      console.log(chunk);
      body.push(chunk);
    });
    //register event listener for end of data
    req.on("end", () => {
      //all chunks are in body now
      const parsedBody = Buffer
        .concat(body) //concat chunks
        .toString(); //parse as text

      console.log(parsedBody);
    });
    //write new file
    fs.writeFileSync("message.txt", "DUMMY TEXT");
    res.statusCode = 302; //redirect
    res.setHeader("Location", "/");
    //return so we break execution
    return res.end();
  }
  //set content type header
  res.setHeader("Content-Type", "text/html");
  //send actual html as response
  res.write("&lt;html&gt;");
  res.write(`&lt;head&gt;
              &lt;title&gt;Basic Node Page&lt;/title&gt;
            &lt;/head&gt;`);
  res.write(`&lt;body&gt;
              &lt;h1&gt;Hello Node JS&lt;/h1&gt;
             &lt;/body&gt;
            `);
  res.write("&lt;/html&gt;");
  //end response and send it to client
});

//start the server
server.listen(3000);

      </pre
    >
    <p class="text">
      If we run the server now and make a
      <span class="snippet">POST</span> rerquest to
      <span class="snippet">/message</span>, we get the following output in the
      terminal:
    </p>
    <div class="devPic">
      <img src="./img/buffer.png" alt="" />
    </div>
    <p class="text">
      Note the <span class="snippet">Buffer</span>chunk above and the parsedBody
      below as text. The parsedBody is formed of
      <span class="snippet">message=test</span> because of the
      <span class="snippet">name</span> attribute on the form.
    </p>
    <p class="text">
      Next we can grab the input value and put it in a variable to be written in
      the text file instead of the dummy text:
    </p>
    <pre class="code">
//import http module
const http = require("http");
//import file system module
const fs = require("fs");

//create server
const server = http.createServer((req, res) => {
  //parse url
  const url = req.url;
  if (url === "/") {
    //redirect
    res.write("&lt;html&gt;");
    res.write(`&lt;head&gt;
                &lt;title&gt;Enter Msg&lt;/title&gt;
              &lt;/head&gt;`);
    res.write(
      `&lt;body&gt;
        &lt;form action='/message' method='POST'&gt;
          &lt;input type='text' name='message'&gt;
          &lt;button type='submit'&gt;Send&lt;/button&gt;
        &lt;/form&gt;
      &lt;/body&gt;`,
    );
    res.write("&lt;/html&gt;");
    //return so we break execution
    return res.end();
  }
  //check url and request type
  if (url === "/message" && req.method === "POST") {
    //register event listener for data
    const body = [];
    req.on("data", (chunk) => {
      console.log(chunk);
      body.push(chunk);
    });
    //register event listener for end
    req.on("end", () => {
      //all chunks are in body now
      const parsedBody = Buffer
        .concat(body) //concat chunks
        .toString(); //parse as text

      const message = parsedBody.split("=")[1];
      //write message to file
      fs.writeFileSync("message.txt", message);
    });

    res.statusCode = 302; //redirect
    res.setHeader("Location", "/");
    //return so we break execution
    return res.end();
  }
  //set content type header
  res.setHeader("Content-Type", "text/html");
  //send actual html as response
  res.write("&lt;html&gt;");
  res.write(`&lt;head&gt;
              &lt;title&gt;Basic Node Page&lt;/title&gt;
            &lt;/head&gt;`);
  res.write(`&lt;body&gt;
              &lt;h1&gt;Hello Node JS&lt;/h1&gt;
             &lt;/body&gt;
            `);
  res.write("&lt;/html&gt;");
  //end response and send it to client
});

//start the server
server.listen(3000);
        </pre
    >
    <p class="text center bold">Event Driven Code execution</p>
    <p class="text">
      The order of execution of the code, is not always the order in which the
      code is written in the file (this is a quirk of asynchronous programming).
    </p>
    <p class="text">
      For instance in the snippet below, the callback function will execute
      after we set the <span class="snippet">statusCode()</span>,
      <span class="snippet">setHeader()</span> and even send the response
      <span class="snippet">res.end()</span> :
    </p>
    <pre class="code">
      //register event listener for end
      req.on("end", () => {
        //callback function executes last
        const parsedBody = Buffer
          .concat(body) //concat chunks
          .toString(); //parse as text
        const message = parsedBody.split("=")[1];
        fs.writeFileSync("message.txt", message);
      });
      //this runs first
      res.statusCode = 302; //redirect
      res.setHeader("Location", "/");
      return res.end();
    </pre>
    <p class="text">
      This has 2 implications:
    </p>
    <p class="text">
      1. The event listener will keep executing even after the response from the
      server is sent.
    </p>
    <p class="text">
      2 . If we want to modify the response in the event listener, the snippet
      above is a bad way to do it, we need to also send the response in the
      event listener (so we need to move the 3 lines that configure the response
      in the callback event listener function):
    </p>
    <pre class="code">
      //register event listener for end
      req.on("end", () => {
        //callback function executes last
        const parsedBody = Buffer
          .concat(body) //concat chunks
          .toString(); //parse as text
        const message = parsedBody.split("=")[1];
        fs.writeFileSync("message.txt", message);
        res.statusCode = 302; //redirect
        res.setHeader("Location", "/");
        return res.end();
      });
    </pre>
    <p class="text">
      NodeJS uses this pattern (of passing a callback event listener function)
      to functions like
      <span class="snippet">http.createServer((req,res) => {});</span> or
      <span class="snippet">req.on("end", cb()=>{})</span>. The request listener
      (callback function) will execute at a later time, asynchronously. When it
      encounters these event listeners, node will register them and will execute
      them only when the event (in this case the request data parsing) finishes.
      When that happens, node triggers the
      <span class="snipept">"end"</span> event and executes the event listener
      registered for it.
    </p>
    <p class="text">
      The good thing about asynchronous programming is that the code execution
      is never paused, for instance in the snippet below, NodeJS will register
      the 2 event listeners and then execute the rest of the code and wait for
      the events that trigger the event listeners to be sent:
    </p>
    <pre class="code">
//check url and request type
if (url === "/message" && req.method === "POST") {
  //register event listener for data
  const body = [];
  req.on("data", (chunk) => {
    console.log(chunk);
    body.push(chunk);
  });
  //register event listener for end
  req.on("end", () => {
    //all chunks are in body now
    const parsedBody = Buffer
      .concat(body) //concat chunks
      .toString(); //parse as text
    const message = parsedBody.split("=")[1];
    fs.writeFileSync("message.txt", message);
    res.statusCode = 302; //redirect
    res.setHeader("Location", "/");
    return res.end();
  });   
}
//the lines below run synchronously (immediately)
//set content type header
res.setHeader("Content-Type", "text/html");
//send actual html as response
res.write("&lt;html&gt;");
res.write(`&lt;head&gt;
            &lt;title&gt;Basic Node Page&lt;/title&gt;
          &lt;/head&gt;`);
res.write(`&lt;body&gt;
            &lt;h1&gt;Hello Node JS&lt;/h1&gt;
            &lt;/body&gt;
          `);
res.write("&lt;/html&gt;");
//end response and send it to client
res.end();
    </pre>
    <p class="text">
      Once the data is submitted
      <span class="snippet">req.on("data", cb)</span> the first event listener
      is executed, and once the data is done being parsed
      <span class="snippet">req.on("end", cb)</span>, the second event listener
      is executed.
    </p>
    <p class="text">
      So if we modify the whole code so far as in the 2 snippets above we get:
    </p>
    <pre class="code">
//import http module
const http = require("http");
//import file system module
const fs = require("fs");

//create server
const server = http.createServer((req, res) => {
  //parse url
  const url = req.url;
  if (url === "/") {
    //redirect
    res.write("&lt;html&gt;");
    res.write(`&lt;head&gt;
                &lt;title&gt;Enter Msg&lt;/title&gt;
              &lt;/head&gt;`);
    res.write(
      `&lt;body&gt;
        &lt;form action='/message' method='POST'&gt;
          &lt;input type='text' name='message'&gt;
          &lt;button type='submit'&gt;Send&lt;/button&gt;
        &lt;/form&gt;
      &lt;/body&gt;`,
    );
    res.write("&lt;/html&gt;");
    //return so we break execution
    return res.end();
  }
  //check url and request type
  if (url === "/message" && req.method === "POST") {
    //register event listener for data
    const body = [];
    req.on("data", (chunk) =&gt; {
      console.log(chunk);
      body.push(chunk);
    });
    //register event listener for end
    req.on("end", () =&gt; {
      //all chunks are in body now
      const parsedBody = Buffer
        .concat(body) //concat chunks
        .toString(); //parse as text
      const message = parsedBody.split("=")[1];
      fs.writeFileSync("message.txt", message);
      res.statusCode = 302; //redirect
      res.setHeader("Location", "/");
      return res.end();
    });
  }
  //set content type header
  res.setHeader("Content-Type", "text/html");
  //send actual html as response
  res.write("&lt;html&gt;");
  res.write(`&lt;head&gt;
              &lt;title&gt;Basic Node Page&lt;/title&gt;
            &lt;/head&gt;`);
  res.write(`&lt;body&gt;
              &lt;h1&gt;Hello Node JS&lt;/h1&gt;
             &lt;/body&gt;
            `);
  res.write("&lt;/html&gt;");
  //end response and send it to client
  res.end();
});

//start the server
server.listen(3000);

    </pre>

    <p class="text">
      If we run now the server, it seems to work properly, it registers the 2
      event listeners<span class="snippet">on("data")</span> and
      <span class="snippet">on.("end")</span> and then it moves on, sets the
      <span class="snippet">Content-Type</span> header, and returns the form and
      the submit button:
    </p>
    <div class="devPic">
      <img src="./img/event.png" alt="" />
    </div>
    <p class="text">
      Hoewever, because of the way we set the code up (so that it sets the
      <span class="snippet">Content-Type</span> header first, when we do submit,
      NodeJS will try to set again the headers in the
      <span class="snippet">on("end")</span> event listener, the server will
      stop and we will get the following error:
    </p>
    <div class="devPic">
      <img src="./img/error.png" alt="" />
    </div>
    <p class="text">
      A fix for this issue would be to return from the
      <span class="snippet">req.on("end")</span> event listener so that the code
      below is not executed anymore and Node will not try to set the
      <span class="snippet">Content-Type</span>header again after having set the
      location one before, and that way we get no error:
    </p>
    <pre class="code">
    //register event listener and return
    return req.on("end", () => {
      //all chunks are in body now
      const parsedBody = Buffer
        .concat(body) //concat chunks
        .toString(); //parse as text
      const message = parsedBody.split("=")[1];
      fs.writeFileSync("message.txt", message);
      res.statusCode = 302; //redirect
      res.setHeader("Location", "/");
      return res.end();
    });
    //code from here on won't run anymore
    </pre>
    <p class="text">
      This event driven architecture (with callback event listener functions)
      allows Node to keep running without executing some specific code until
      it's the time to do so but also without blocking the execution of the
      whole program.
    </p>
    <p class="text bold center">Blocking and non-blocking code</p>
    <p class="text">
      <span class="snippet">writeFileSync()</span> is a synchronous method which
      makes it to block the other code until it finishes running. For our basic
      usecase, there is no need to worry about that because the writing is done
      very fast. But if we were to have to write a much bigger file, everything
      would get blocked until the writing is done.
    </p>
    <p class="text">
      A better approach would be to use
      <span class="snippet">writeFile()</span> which works asynchronously and
      takes a callback function as an argument (so node has another event
      listener registered by default with this method and we can use it to
      perform the writing operation asynchronously):
    </p>
    <pre class="code">
//import http module
const http = require("http");
//import file system module
const fs = require("fs");

//create server
const server = http.createServer((req, res) => {
//parse url
const url = req.url;
if (url === "/") {
  //redirect
  res.write("&lt;html&gt;");
  res.write(`&lt;head&gt;
              &lt;title&gt;Enter Msg&gt;/title&gt;
            &lt;/head&gt;`);
  res.write(
    `&lt;body&gt;
      &lt;form action='/message' method='POST'&gt;
        &lt;input type='text' name='message'&gt;
        &lt;button type='submit'&gt;Send&lt;/button&gt;
      &lt;/form&gt;
    &lt;/body&gt;`,
  );
  res.write("&lt;/html&gt;");
  //return so we break execution
  return res.end();
}
//check url and request type
if (url === "/message" && req.method === "POST") {
  //register event listener for data
  const body = [];
  req.on("data", (chunk) => {
    console.log(chunk);
    body.push(chunk);
  });
  //register event listener for end
  return req.on("end", () => {
    //all chunks are in body now
    const parsedBody = Buffer
      .concat(body) //concat chunks
      .toString(); //parse as text
    const message = parsedBody.split("=")[1];
    //register new event listener here
  fs.writeFile("message.txt", message, (err) => {
      res.statusCode = 302; //redirect
      res.setHeader("Location", "/");
      return res.end();
    });
  });
}
//set content type header
res.setHeader("Content-Type", "text/html");
//send actual html as response
res.write("&lt;html&gt;");
res.write(`&lt;head&gt;
            &lt;title&lt;Basic Node Page&lt;/title&gt;
          &lt;/head&gt;`);
res.write(`&lt;body&gt;
            &lt;h1&gt;Hello Node JS&lt;/h1&gt;
            &lt;/body&gt;
          `);
res.write("&lt;/html&gt;");
//end response and send it to client
res.end();
});

//start the server
server.listen(3000);

    </pre>
    <p class="text bold center">
      Single Thread, Event Loop and Blocking Code
    </p>
    <p class="text">
      NodeJS uses a single JS thread.Code which needs to do some more complex
      operations (like working with files) is handled by the worker threads (in
      the Worker Pool). The Event Loop handles the callback function to be
      executed after the file writing operation has finished. However for
      complex operations (such as working with the file system, the worker pool
      does the work, and the it is closely intervened with the OS so it can
      allocate more threads in the system).
    </p>
    <p class="text center bold">
      The event loop
    </p>
    <p class="text">
      It is a loop that is started by node and that handles all the callbacks.It
      checks if there are timer callbacks we have set like
      <span class="snippet">setTimeout()</span> or
      <span class="snippet">setInterval()</span>. Next it checks I/O related
      callbacks (like file operations or network operations).
    </p>
    <p class="text">
      After that it checks the Poll operations (new I/O events) and tries to
      execute their callbacks or register them as pending callbacks.
    </p>
    <p class="text">
      Next it checks the <span class="snippet">setImmediate()</span> callbacks
      and execute them.
    </p>
    <p class="text">Next it checks the Close event Callbacks.</p>
    <p class="text">
      Finally the loop might stope with
      <span class="snippet">process.exit</span> or it might continue if there
      still are event listeners registered like when using
      <span class="snippet">createServer()</span>.
    </p>
    <p class="text">
      Regarding the potential security implications of handling multiple server
      requests in a single thread, we should know that each request has its own
      event listener callback function listed, and this way the data of each
      request is handled and scoped separately.
    </p>
    <p class="text center bold">Using the node module system</p>
    <p class="text">
      We can split the <span class="snippet">server.js</span>file in multiple
      files
    </p>
  </body>
</html>
